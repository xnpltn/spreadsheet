package views

import (
"spreadsheet/spdb/models"
)

templ EditView(sheet models.Sheet) {
<style>
  .cell-row {
    display: flex;
  }

  .cell {
    border: 1px solid #e5e7eb;
    padding: 0.5rem;
    text-align: center;
    width: 100%;
    min-width: 100px;
    font-size: 0.875rem;
    /* Small font size */
    flex-grow: 1;
  }

  .cell-header {
    background-color: #f3f4f6;
    font-weight: bold;
  }

  .active {
    background-color: #d1d5db;
  }

  #info-container {
    margin: 1rem;
    overflow-x: auto;
    /* Make the container scrollable horizontally */
  }

  #export-btn {
    margin-bottom: 1rem;
  }
</style>
<h1 class="text-2xl font-bold text-center my-4">Edit view</h1>
<div id="info-container" class="p-4 bg-white shadow-lg rounded-lg">
  <h2 class="text-xl font-semibold">{ sheet.Name }</h2>
  <button id="export-btn" class="bg-blue-500 text-white px-4 py-2 rounded mt-4">Export</button>
  <span id="active-container" class="block my-4"></span>
  <div id="scon" class="overflow-auto whitespace-nowrap"></div> <!-- Ensure horizontal scrolling -->
</div>
<script>
  const sContainer = document.getElementById("scon");
  const downloadButton = document.getElementById("export-btn");
  const activeContainer = document.getElementById("active-container");
  const alphabets = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

  const ROWS = 25;
  const COLS = alphabets.length + 1;
  let spreadSheet = [];

  class Cell {
    constructor(isHeader, disabled, data, row, column, rowName, columnName, active = false) {
      this.isHeader = isHeader;
      this.disabled = disabled;
      this.data = data;
      this.row = row;
      this.column = column;
      this.active = active;
      this.rowName = rowName;
      this.columnName = columnName;
      this.name = `${this.columnName}${this.rowName}`;
      this.sheetID = undefined


    }

    //get name() {
    //  return `${this.columnName}${this.rowName}`;
    //}
  }

  initSpreadSheet();
  function getSheetId(location) {
    const url = new URL(location);
    const parts = url.pathname.split('/');
    const id = parts[parts.length - 1];
    return id

  }

  downloadButton.addEventListener("click", (_) => {
    let csv = "";
    for (let i = 0; i < spreadSheet.length; i++) {
      csv += spreadSheet[i].filter(item => !item.isHeader).map(item => item.data).join(",") + "\r\n";
    }
    const csvBlob = new Blob([csv]);
    const csvFileUrl = URL.createObjectURL(csvBlob);
    const a = document.createElement("a");
    a.href = csvFileUrl;
    a.download = "Exported.csv";
    a.click();
  });

  function initSpreadSheet() {
    for (let i = 0; i < ROWS; i++) {
      let spreadSheetRow = [];
      for (let j = 0; j < COLS; j++) {
        let cellData = "";
        let isHeader = false;
        let isDisabled = false;
        if (j === 0) {
          cellData = i;
          isHeader = true;
          isDisabled = true;
        }

        if (i === 0) {
          cellData = alphabets[j - 1];
          isDisabled = true;
          isHeader = true;
        }
        if (!cellData) {
          cellData = "";
        }
        let rowName = i;
        let columnName = alphabets[j - 1];
        const cell = new Cell(isHeader, isDisabled, cellData, i, j, rowName, columnName, false);
        spreadSheetRow.push(cell);
      }
      spreadSheet.push(spreadSheetRow);
    }

    drawSheet();
  }

  function drawSheet() {
    sContainer.innerHTML = "";
    for (let i = 0; i < spreadSheet.length; i++) {
      const rowContainerEl = document.createElement("div");
      rowContainerEl.className = "cell-row";
      for (let j = 0; j < spreadSheet[i].length; j++) {
        const cell = spreadSheet[i][j];
        rowContainerEl.append(createCellEl(cell));
      }
      sContainer.append(rowContainerEl);
    }
  }


  function createCellEl(cell) {
    const cellEl = document.createElement("input");
    cellEl.className = `cell ${cell.isHeader ? 'cell-header' : ''}`;
    cellEl.id = "cell_" + cell.row + cell.column;
    cellEl.value = cell.data;
    cellEl.disabled = cell.disabled;
    cellEl.onclick = () => handlerCellClick(cell);
    cellEl.onchange = async (e) => await handlerCellOnchange(e.target.value, cell);
    return cellEl;
  }

  function handlerCellClick(cell) {
    clearActiveState();
    const rowHeader = spreadSheet[cell.row][0];
    const columnHeader = spreadSheet[0][cell.column];
    const columnHeaderEl = getElFromRowCol(columnHeader.row, columnHeader.column);
    const rowHeaderEl = getElFromRowCol(rowHeader.row, rowHeader.column);
    columnHeaderEl.classList.add("active");
    rowHeaderEl.classList.add("active");
    activeContainer.innerText = cell.name;
  }



  console.log(window.location.href)
  async function handlerCellOnchange(data, cell) {

    cell.data = data;
    cell.sheetID = parseInt(getSheetId(window.location.href))
    try {
      // Send data to the server
      const response = await fetch('/api/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(cell),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const result = await response.json();
      console.log('Save successful:', result);
    } catch (error) {
      console.error('Error saving data:', error);
    }
  }

  function clearActiveState() {
    for (let i = 0; i < spreadSheet.length; i++) {
      for (let j = 0; j < spreadSheet[i].length; j++) {
        const cell = spreadSheet[i][j];
        if (cell.isHeader) {
          let cellEl = getElFromRowCol(cell.row, cell.column);
          cellEl.classList.remove("active");
        }
      }
    }
  }

  function getElFromRowCol(row, col) {
    return document.querySelector("#cell_" + row + col);
  }
</script>
}
